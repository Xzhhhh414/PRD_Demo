# Tap小游戏多人对战业务流程 - 一期版本

## 1. 总体业务流程图

```
开发者游戏启动
        ↓
   【初始化阶段】
   初始化SDK（自动创建Manager + 注册事件处理器）
        ↓
   连接服务（获取playerId用于身份判断）
        ↓
   【匹配阶段】
   快速匹配 ← → 创建房间
        ↓
   【等待阶段】
   等待对手加入房间
        ↓
   【对战阶段】
   根据游戏类型选择同步方案：

   | 方案A: 帧同步方案（实时对战） | 方案B: 状态同步方案（回合制）✅ |
   |:---|:---|
   | ↓ 开始对战 | SendCustomMessage |
   | ↓ SendInput循环 | |
   | ↓ 对战结束 | |
        ↓
   【结束阶段】
   离开房间 → 重新匹配/退出游戏
        ↓
   【清理阶段】
   终止化SDK（自动销毁Manager）
```

---

## 2. 详细业务流程

### 2.1 初始化阶段

**初始化流程：**

```
游戏启动
    ↓
SDK初始化（自动创建Manager + 注册事件处理器）
    ↓
初始化成功
    ↓
连接多人对战服务
    ↓
获取playerId（用于判断"我是谁"和"谁是房主"）
    ↓
进入匹配阶段
```

**关键步骤：**
1. **SDK初始化**：调用`Initialize(eventHandler)`方法，传入实现了ITapBattleEventHandler接口的事件处理器
2. **自动创建Manager**：SDK自动创建并管理OnlineBattleManager实例
3. **事件处理器注册**：注册的ITapBattleEventHandler将接收所有异步事件通知
4. **连接服务**：调用Connect获取playerId，这是判断玩家身份的核心数据

---

### 2.2 匹配阶段

**匹配流程：**

```
匹配阶段开始
    ↓
选择匹配方式
    ├── 快速匹配 → MatchRoom → 服务器匹配算法
    │                              ↓
    │                        找到合适房间？
    │                        ├── 是 → 加入现有房间
    │                        └── 否 → 自动创建新房间
    │                              ↓
    └── 创建房间 → CreateRoom → 创建专属房间
                              ↓
                        匹配成功 → 进入房间 → 等待对手阶段
```

---

### 2.3 等待对手阶段

**等待对手流程：**

```
匹配成功
    ↓
玩家A进入房间
    ↓
房间是否已满？
    ├── 否 → 等待对手加入 → 玩家B加入房间 → 触发OnPlayerEnterRoom
    └── 是 → 房间已满2人
              ↓
        根据游戏类型选择同步方案
        ├── 帧同步方案 → 房主调用StartBattle
        └── 状态同步方案 → 直接开始游戏（无需StartBattle）
              ↓
        对战阶段
```

---

### 2.4 对战阶段

开发者可以根据游戏类型选择两种同步方案：

---

#### 方案A：帧同步方案（适用于实时对战游戏）

**适用游戏类型**：
- 需要高频操作（射击、格斗、MOBA等）
- 需要确定性随机数
- 对同步要求高

**对战阶段流程：**

```
房主调用StartBattle
    ↓
触发OnBattleStart（获取seed）
    ↓
创建确定性随机数生成器
    ↓
进入帧同步循环 ←─────┐
    ↓         　   │
玩家操作输入           │
    ↓                │
SendInput            │
    ↓                │
服务器收集本帧操作      │
    ↓                │
服务器广播帧数据       │
    ↓                │
OnBattleFrame        │
    ↓                │
应用帧数据到游戏       │
    ↓                │
对战是否结束？         │
    ├── 否 ──────────┘
    └── 是 → StopBattle → 触发OnBattleStop → 清理对战资源
```

**📊 帧同步 - 数据上传与广播详细流程**

```
【玩家端操作】
玩家A按下移动键 → 生成移动指令 → SendInput上传
      │
      ↓
玩家B按下攻击键 → 生成攻击指令 → SendInput上传
      │
      ↓
【服务器收集处理】
收集第N帧的所有指令
      ↓
本帧时间到 → 打包所有指令 → 广播给所有玩家
      ↓
【玩家端接收执行】
玩家A收到完整帧数据 → 执行自己+对手的指令
      ↓
玩家B收到完整帧数据 → 执行自己+对手的指令
      ↓
游戏画面同步更新
```

**🔄 帧同步 - 数据流转的5个关键步骤**

1. **玩家操作上报**：SendInput 上报操作数据
2. **服务器数据收集**：收集当前帧所有操作
3. **数据打包广播**：打包成帧数据包 + 帧编号
4. **客户端接收处理**：解析帧数据，应用所有操作
5. **画面同步更新**：确保双方看到相同结果

---

#### 方案B：状态同步方案（适用于回合制游戏）✅ 推荐

**适用游戏类型**：
- 回合制游戏（五子棋、象棋、卡牌等）
- 操作频率低（每秒 < 20次）
- 不需要确定性随机数

**对战阶段流程：**

```
房间满员（无需StartBattle）
    ↓
玩家初始化游戏场景
    ↓
进入游戏循环 ←─────────┐
    ↓                  │
玩家操作（如落子）       │
    ↓                  │
SendCustomMessage     │
（发送操作事件）        │
    ↓                  │
所有玩家收到            │
OnCustomMessage       │
    ↓                  │
应用操作到本地游戏      │
（更新棋盘、切换回合等） │
    ↓                  │
游戏是否结束？          │
    ├── 否 ───────────┘
    └── 是 → 显示结算 → LeaveRoom
```

**📊 状态同步 - 数据流转详细流程**

```
【玩家操作】
玩家A落子 → 构造事件数据（包含所有必要信息）
      ↓
【发送消息】
SendCustomMessage({
  eventCode: PLAYER_MOVE,
  data: { pId, x, y, nextPlayer, timestamp }
})
      ↓
【消息广播】
服务器转发消息 → 所有玩家收到 OnCustomMessage
      ↓
【应用操作】
所有玩家执行相同逻辑：
  - 在棋盘上落子
  - 切换当前回合玩家
  - 更新游戏状态
  - 检查胜负
      ↓
保持所有客户端状态一致
```

**🔄 状态同步 - 关键特点**

1. **事件驱动**：通过 SendCustomMessage 发送操作事件
2. **消息包含完整信息**：一条消息包含操作所需的所有数据
3. **本地状态管理**：每个客户端本地维护游戏状态
4. **轻量高效**：只在需要时发送，不需要每帧上报
5. **易于调试**：消息清晰，逻辑简单

**💡 状态同步 vs 帧同步**

| 特性 | 帧同步 | 状态同步 |
|------|--------|---------|
| **适用游戏** | 实时对战 | 回合制 |
| **消息频率** | 高（每秒30-60次） | 低（每秒<3次） |
| **网络开销** | 大 | 小 |
| **服务器压力** | 大 | 小 |
| **实现复杂度** | 高 | 低 |
| **调试难度** | 难 | 易 |

**✅ 实际验证**：五子棋使用状态同步方案，经过完整测试，验证可行性。

---

### 2.5 异常处理流程

**异常处理流程：**

```
对战进行中
    ↓
异常类型分类处理：

【网络断线处理】
网络断线 → OnDisconnected → 显示断线提示
（开发者可根据游戏类型决定是否终止对战）

【对手掉线处理】
对手掉线 → OnPlayerOffline → 收到掉线通知
（开发者可根据游戏类型决定是否终止对战）

【服务异常处理】
服务异常 → OnBattleServiceError → 强制退出对战 → 返回主菜单
```

**异常处理策略：**

#### 网络断线
- **检测机制**：连接心跳监测
- **事件通知**：OnDisconnected
- **处理策略**：开发者自行决定（继续游戏/结束对战/等待重连）

#### 对手掉线
- **掉线通知**：OnPlayerOffline事件
- **处理策略**：开发者自行决定（超时判负/等待重连/平局）

#### 服务异常
- **异常检测**：OnBattleServiceError事件
- **处理策略**：立即清理所有对战状态
- **用户体验**：友好的错误提示

---

### 2.6 结束阶段

**结束阶段流程：**

```
对战结束
    ↓
清理对战资源
    ├── 帧同步方案：StopBattle → OnBattleStop → 释放随机数生成器
    └── 状态同步方案：无需特殊清理
    ↓
显示对战结果
    ↓
用户选择下一步操作：
    ├── 继续游戏 → 重新匹配 → 回到匹配阶段
    ├── 离开房间 → LeaveRoom → 回到匹配阶段
    └── 退出游戏 → FinalizeSDK → 游戏退出
```

---

## 3. 关键时机点和事件流

### 3.1 成功流程的事件序列

#### 帧同步方案
```
Initialize(success) → 初始化成功
    ↓
Connect(success) → 连接服务成功，获取playerId
    ↓
MatchRoom/CreateRoom → 匹配/创建房间成功
    ↓
OnPlayerEnterRoom → 对手加入房间
    ↓
StartBattle → 房主开始对战
    ↓
OnBattleStart → 对战开始，获得seed和房间信息
    ↓
SendInput + OnBattleFrame → 循环上传操作和接收帧数据
    ↓
StopBattle → 房主结束对战
    ↓
OnBattleStop → 对战结束
    ↓
LeaveRoom(success) → 离开房间
```

#### 状态同步方案 ✅
```
Initialize(success) → 初始化成功
    ↓
Connect(success) → 连接服务成功，获取playerId
    ↓
MatchRoom/CreateRoom → 匹配/创建房间成功
    ↓
OnPlayerEnterRoom → 对手加入房间
    ↓
游戏开始（无需StartBattle）
    ↓
SendCustomMessage + OnCustomMessage → 发送和接收操作事件（战斗核心）
    ↓
游戏结束 → LeaveRoom(success) → 离开房间
```

---

### 3.2 异常流程的事件序列

```
正常流程中断
    ↓
OnDisconnected / OnPlayerOffline / OnBattleServiceError
    ↓
异常处理逻辑（开发者自行决定）
    ↓
清理资源，回到匹配阶段或退出游戏
```

---

## 4. 两种同步方案对比

### 4.1 帧同步方案

**核心API**：
- `StartBattle` - 开始对战
- `SendInput` - 上传操作
- `OnBattleFrame` - 接收帧数据
- `StopBattle` - 结束对战

**特点**：
- ✅ 适合实时对战游戏
- ✅ 确定性随机数支持
- ✅ 严格同步
- ⚠️ 网络开销大
- ⚠️ 服务器压力大

**适用游戏**：射击、格斗、MOBA、竞速等

---

### 4.2 状态同步方案 ✅

**核心API**：
- `SendCustomMessage` - 发送操作事件
- `OnCustomMessage` - 接收操作事件

**可选API**（房间管理，非战斗必需）：
- `UpdateRoomProperties` - 更新房间配置（如房间名、地图等）
- `UpdatePlayerCustomProperties` - 更新玩家信息（如昵称、等级等）

> **频率限制**: `UpdateRoomProperties` 和 `SendCustomMessage` 这2个API共享每秒50次的调用频率限制

**特点**：
- ✅ 适合回合制游戏
- ✅ 网络开销小
- ✅ 实现简单
- ✅ 易于调试
- ✅ 战斗中只用 SendCustomMessage 即可
- ⚠️ UpdateRoomProperties 和 SendCustomMessage 共享频率限制（50次/秒）

**适用游戏**：五子棋、象棋、卡牌、回合RPG等

**实际验证**：✅ 五子棋完整测试通过

---

### 4.3 方案选择建议

| 游戏类型 | 操作频率 | 推荐方案 | 原因 |
|---------|---------|---------|------|
| 射击、格斗 | 每秒30+次 | 帧同步 | 需要高频同步 |
| MOBA、RTS | 每秒10+次 | 帧同步 | 需要确定性 |
| 五子棋、象棋 | 每秒<3次 | 状态同步 ✅ | 轻量高效 |
| 卡牌游戏 | 每秒<5次 | 状态同步 ✅ | 简单易实现 |
| 回合RPG | 每秒<2次 | 状态同步 ✅ | 网络开销小 |

---

## 5. 流程图总结

### 简化版核心流程

#### 帧同步方案
```
初始化SDK → 连接服务 → 匹配房间 → 等待对手 → 开始对战 → 帧同步 → 结束对战 → 离开房间
    ↓         ↓         ↓         ↓         ↓        ↓        ↓         ↓
Initialize  Connect  Match  PlayerJoin StartBattle SendInput StopBattle LeaveRoom
                                                       ↓
                                                  OnBattleFrame
```

#### 状态同步方案 ✅
```
初始化SDK → 连接服务 → 匹配房间 → 等待对手 → 开始游戏 → 状态同步 → 结束游戏 → 离开房间
    ↓         ↓         ↓         ↓         ↓        ↓         ↓         ↓
Initialize  Connect  Match  PlayerJoin  (直接)  SendCustom  (直接)  LeaveRoom
                                                Message
                                                   ↓
                                              OnCustomMessage
                                              OnRoomPropertiesChange
```